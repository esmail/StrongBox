import socket
import ssl
import client_encryption
import os
import cPickle # Supposed to be orders of magnitude faster than `pickle` with some limitations on serializing new classes
import hashlib
import random
import shutil
import struct

class Peer:
  
  #################
  # Object fields #
  #################
  
  # List this object's fields (what's the Pythonic way?)
  # TODO: Beware the unsafety if accessing these fields if we end up using multiple threads.
  listening_port = 51337 # TODO: Magic number. Ideally would want listening listening_port number to be configurable per peer.
  peers = None  # A mapping from UUID to IP address (peer user ID as well?).
  peer_data_file = None # Non-volatile storage for peer data.
  # FIXME: Need to use OpenSSL from the command line to generate X.509 key pairs that can be used by the `ssl` package,
  #  then scrape just the key data from those files for use with PyCrypto.
  #  See https://stackoverflow.com/questions/12911373/how-do-i-use-a-x509-certificate-with-pycrypto 
  private_key_file = None
  x509_cert_file = None
  encryption = None
  peer_id = None
  store_id = None
  stores = None
  debug = None
  
  
  #################
  # Setup methods #
  #################
  
  # Peer IDs are meant to uniquely identify a node. They are generated by taking
  #  the SHA-256 hash of the user's public key "salted" with a random number
  def generate_peerId(self):
    peer_unique_string = self.encryption.import_public_key().exportKey() + str(random.SystemRandom().random())
    self.peer_id = hashlib.sha256(peer_unique_string).digest()
    
  # Store IDs are meant to uniquely identify a store/user. They are essentially
  #  the RSA public key, but we use use their SHA-256 hash to "flatten" them to
  #  a shorter, predictable length.
  def generate_storeId(self):
    self.peer_id = hashlib.sha256(self.encryption.import_public_key().exportKey()).digest()
  
  # Use a file to permanently store certain data.
  # NOTE: MAKE SURE ALL CALLS TO THIS UNSAFE FUNCTION PROPERLY EXPECT THE SAME
  #  TYPES OF DATA AS IS STORED IN calls to `update_peer_data`
  def load_peer_data(self):
    try:
      # Load the data file
      if os.path.isfile(self.peer_data_file):
        with open(self.peer_data_file, 'r') as f:
          data = cPickle.load(f)
      else:
        raise Exception()
    except:
      try:
        # Load the backup file
        if os.path.isfile(self.backup_data_file):
          with open(self.backup_data_file, 'r') as f:
            data = cPickle.load(f)
            shutil.copyfile(self.backup_data_file, self.peer_data_file)
        else:
          raise Exception()
      except:
        # Generate a new empty file and store the initial metadata
        open(self.peer_data_file, 'w').close()
        self.generate_peerId()
        self.peers = dict()
        self.generate_storeId()
        self.stores = dict()
        data = (self.peers, self.peer_id, self.store_id, self.stores)
        self.update_peer_data(data)
    return data
  
  
  def __init__(self, directory=os.getcwd(), debug=False):
    self.debug = debug
    
    # Get the encryption object
    self.encryption = client_encryption.ClientEncryption(directory)
    
    self.private_key_file = self.encryption.private_key_loc
    self.x509_cert_file = self.encryption.x509_cert_loc
    self.peer_data_file = os.path.join(self.encryption.personal_path_full,'peer_data_file.pickle')
    self.backup_data_file = self.peer_data_file + '.bak'
    
    (self.peers, self.peer_id, self.store_id, self.stores) = self.load_peer_data()

  ###########################
  # Stored metadata methods #
  ###########################
  
  # Ensure that each time permanent metadata are altered, those changes are stored to disk
  def update_peer_data(self, data):
    shutil.copyfile(self.peer_data_file, self.backup_data_file)
    with open(self.peer_data_file, 'w') as f:
      cPickle.dump(data, f)
    (self.peers, self.peer_id, self.store_id, self.stores) = data
    
  def record_peer_ip(self, peer_id, peer_ip):
    # Do nothing if the mapping is already known
    if (peer_id in self.peers.keys()) and (self.peers[peer_id] == peer_ip):
      return
    peers_new = self.peers.copy()
    peers_new[peer_id] = peer_ip
    data = (peers_new, self.peer_id, self.store_id, self.stores)
    self.update_peer_data(data)
    
  def record_store_association(self, peer_id, store_id):
    # Do nothing if the store to peer association is already known
    if (store_id in self.stores) and (peer_id in self.stores[store_id]):
      return
    
    stores_new = self.stores.copy()
    
    # The store was previously unknown
    if store_id not in self.stores:
      stores_new[store_id]  = list()
    
    stores_new[store_id]  = stores_new[store_id].append(peer_id)
    data = (self.peers, self.peer_id, self.store_id, stores_new)
    self.update_peer_data(data)
  
  # Associate a store to a peer
  def associate_store(self, peer_id, store_id):
    if store_id not in self.stores:
      # Initialize the folder structure to back up this store
      # FIXME: DO ACTUAL WORK HERE
      None
    # Ensure this store association is recorded
    self.record_store_association(peer_id, store_id)
    
  def record_peer_key(self, peer_pubkey):
    # FIXME: DO THE WORK
    None

  ########################
  # Steady-state methods #
  ########################
  


  def connect_to_peer(self, uuid):
    # TODO: Raises `KeyError` exception on invalid UUID.
    ip = self.peers[uuid]
    s = ssl.wrap_socket( socket.socket(socket.AF_INET, socket.SOCK_STREAM), ssl_version=ssl.PROTOCOL_SSLv3)
    s.connect((ip, self.listening_port))
    return s
  
  def create_listening_socket(self):
    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.bind(('', self.listening_port))
    return s
  
  
  
  def peer_client_session(self, skt_ssl):
    # Identify yourself to the peer server.
    self.send_identity(skt_ssl)
    
    # Get the response
    message_id, pickled_payload = self.receive(skt_ssl)
    # Associate, if requested
    if message_id == message_ids['assoc_req']:
      # Acknowledge the request, supplying own public key
      self.send_assoc_ack(skt_ssl)
      # Do local association
      (peer_id, store_id) = unpicklers['assoc_req'](pickled_payload)
      self.associate_store(peer_id, store_id)
      
    # Unexpected message
    elif message_id != message_ids['identity_ack']:
      raise Exception()
  
  
    

  def peer_server_session(self, skt_ssl, peer_ip):
    # Get the peer client's peer ID.
    (message_id, pickled_payload) = self.receive(skt_ssl)
    if message_id != message_ids['identity']:
      # All sessions must begin with the peer client sending identification
      raise Exception()
    (peer_id, store_id) = unpicklers['identity'](pickled_payload)
        
    # Acknowledge if the peer is known
    if peer_id in self.peers.keys():
      self.send_identity_ack(skt_ssl)
    # If the peer is unknown, request association
    else:
      self.send_assoc_req(skt_ssl)
      # Get the response
      (message_id, pickled_payload) = self.receive(skt_ssl)
      if message_id != message_ids['assoc_ack']:
        raise Exception()
      peer_pubkey = unpicklers['assoc_ack'](pickled_payload)
      self.record_peer_key(peer_pubkey)
      # Do association
      self.associate_store(peer_id, store_id)
          
    # Ensure the IP address we have recorded for this peer is up to date
    self.record_peer_ip(peer_id, peer_ip)
    
      
    

  def run(self):
    skt_listener = self.create_listening_socket()
    skt_listener.listen(1) # FIXME: Will need to deal with multiple peer clients eventually
    skt_raw, ip = skt_listener.accept()
    skt_ssl = ssl.wrap_socket(skt_raw, server_side=True, keyfile=self.private_key_file, certfile=self.x509_cert_file, ssl_version=ssl.PROTOCOL_SSLv3)
    try:
      self.peer_server_session(skt_ssl, ip)
    except:
      skt_ssl.shutdown(socket.SHUT_RDWR)
      skt_ssl.close()

  #######################
  # Interaction methods #
  #######################
  
  # Ask a peer what revision number they have for a particular store
#   def get_peer_revision(self, skt, peer_id, store_id):
    
    

  #####################
  # Messaging methods #
  #####################
  def send(self, skt, message_id, message_data):
    pickled_payload = cPickle.dumps(message_data)
    message_body = (message_id, pickled_payload)
    pickled_message = cPickle.dumps(message_body)
    skt.send(struct.pack('!I', len(pickled_message))+pickled_message)
    
  
  def send_identity(self, skt):
    message_id = message_ids['identity']
    message_data = (self.peer_id, self.store_id)
    self.send(skt, message_id, message_data)
    
  def send_identity_ack(self, skt):
    message_id = message_ids['identity_ack']
    message_data = None
    self.send(skt, message_id, message_data)
      
  def send_assoc_req(self, skt):
    message_id = message_ids['assoc_req']
    message_data = (self.peer_id, self.store_id)
    self.send(skt, message_id, message_data)
      
  def send_assoc_ack(self, skt):
    message_id = message_ids['assoc_ack']
    message_data = self.encryption.import_public_key().exportKey() # Own public key in string format
    self.send(skt, message_id, message_data)
      
  def receive(self, skt):
    message_buffer = skt.recv(4096)
    length_received = len(message_buffer)
    
    if length_received >= 4:
      length = struct.unpack('!I',message_buffer[0:4])[0]
      
      # Get the rest of the message if incomplete
      # FIXME: This helps, but doesn't guarantee a complete message
      if length_received < (length + 4):
        message_buffer += skt.recv((length + 4) - length_received)
      
      # Unpickle the message contents
      pickled_message = message_buffer[4:4+length]
      (message_id, pickled_payload) = cPickle.loads(pickled_message)
      return message_id, pickled_payload

  #################################
  # Debug and development methods #
  #################################
  
 
  #########
  # Tests #
  #########
  
  def test_client_ssl(self, peer_ip):
    # FIXME: This modifies the metadata file, might not want such mangling
    self.record_peer_ip(-1, peer_ip)
    s = self.connect_to_peer(-1)
    print 'Peer Client: Connected to peer, transmitting important data twice.'
    s.write('oh hai')
    s.write('oh hai')
    s.close()
    
  def test_server_ssl(self):
    skt_listener = self.create_listening_socket()
    skt_listener.listen(1)
    skt_raw, _ = skt_listener.accept()
    print 'Peer Server: A peer is attempting to connect'
    skt_ssl = ssl.wrap_socket(skt_raw, server_side=True, keyfile=self.private_key_file, certfile=self.x509_cert_file, ssl_version=ssl.PROTOCOL_SSLv3)
    print 'Peer Server: Data received from peer; displaying decrypted: '+skt_ssl.recv(4096)
    print 'Peer Server: Data received from peer; displaying encrypted: '+skt_raw.recv(4096)
    skt_ssl.close()
    skt_raw.close()
    skt_listener.close()
    

  def test_client_handshake(self, peer_ip):
    # FIXME: This modifies the metadata file, might not want such mangling
    self.record_peer_ip(-1, peer_ip)
    skt_ssl = self.connect_to_peer(-1)
    try:
      self.peer_client_session(skt_ssl)
    except:
      skt_ssl.shutdown(socket.SHUT_RDWR)
      skt_ssl.close()
      raise
   
  def test_server_handshake(self):
    skt_listener = self.create_listening_socket()
    skt_listener.listen(1) # FIXME: Will need to deal with multiple peer clients eventually
    skt_raw, ip = skt_listener.accept()
    skt_ssl = ssl.wrap_socket(skt_raw, server_side=True, keyfile=self.private_key_file, certfile=self.x509_cert_file, ssl_version=ssl.PROTOCOL_SSLv3)
    try:
      self.peer_server_session(skt_ssl, ip)
    except:
      skt_ssl.shutdown(socket.SHUT_RDWR)
      skt_ssl.close()
      raise
    




def unpickle_identity(pickled_payload):
  (peer_id, store_id) =  cPickle.loads(pickled_payload)
  return (peer_id, store_id)

def unpickle_assoc_req(pickled_payload):
  (peer_id, store_id) =  cPickle.loads(pickled_payload)
  return (peer_id, store_id)

def unpickle_assoc_ack(pickled_payload):
  peer_pubkey =  cPickle.loads(pickled_payload)
  return peer_pubkey

message_ids = {'identity': 0,
               'identity_ack': 1,
               'assoc_req': 2,
               'assoc_ack': 3}
unpicklers = {'identity': unpickle_identity,
              #'identity_ack': Has no data to unpickle
              'assoc_req': unpickle_assoc_req,
              'assoc_ack': unpickle_assoc_ack
              }

    
def main():
  print 'Executing peer connection test.'
  import threading
  client = Peer(debug=True)
  server = Peer(debug=True)
  
#   t1 = threading.Thread(target=server.test_server_ssl, args=())
#   t2 = threading.Thread(target=client.test_client_ssl, args=('localhost',))
  t1 = threading.Thread(target=server.test_server_handshake, args=())
  t2 = threading.Thread(target=client.test_client_handshake, args=('localhost',))
  t1.start()
  t2.start()
  t2.join()
  t1.join()


if __name__ == '__main__':
  main()
